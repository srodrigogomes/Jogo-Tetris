<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tetris Infantil com Poderes</title>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        /* Estilos Globais */
        :root {
            --cor-fundo-fase1: #87CEEB; /* Céu azul claro */
            --cor-fundo-fase2-ceu: #87CEEB;
            --cor-fundo-fase2-estrada: #b0b0b0; /* Cinza da estrada */
            --cor-fundo-fase2-grama: #90EE90; /* Verde claro */
            --cor-fundo-fase3: #1a237e; /* Noite azul escura */
            
            --cor-borda: #333;
            --cor-texto: #1e1e1e;
            --cor-painel: rgba(255, 255, 255, 0.7);
            --cor-poder: #fff2a8;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Fredoka', sans-serif;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            color: var(--cor-texto);
            transition: background-color 0.5s ease;
        }

        /* O contêiner principal do jogo que muda de fundo */
        #game-container {
            padding: 20px;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            display: flex;
            gap: 20px;
            transition: background 0.8s ease-in-out;
            position: relative;
            overflow: hidden; /* Importante para os fundos SVG */
        }
        
        /* Efeito de piscar ao mudar de fase */
        .fase-change-flash {
            animation: flash 0.5s ease-out;
        }
        @keyframes flash {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.2; }
        }


        /* Estilos do Canvas do Jogo */
        canvas {
            border: 3px solid var(--cor-borda);
            border-radius: 10px;
            background-color: rgba(255, 255, 255, 0.4); /* Fundo semi-transparente */
            display: block;
            transition: filter 0.3s ease;
        }

        /* Efeito de Câmera Lenta */
        .slow-mo {
            filter: hue-rotate(60deg) saturate(1.5);
        }

        /* Painel de Informações (Pontos, Linhas, Fase) */
        #info-panel {
            width: 150px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .info-box {
            background-color: var(--cor-painel);
            border: 3px solid var(--cor-borda);
            border-radius: 10px;
            padding: 15px;
            text-align: center;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
        }

        /* Caixa de poder especial */
        .power-box {
            background-color: var(--cor-poder);
        }
        .power-box h3 {
            color: #b8860b;
        }
        .power-box p {
            color: #d9534f;
        }

        .info-box h3 {
            font-size: 1.1em;
            margin-bottom: 5px;
            color: #555;
        }

        .info-box p {
            font-size: 1.8em;
            font-weight: 600;
        }

        /* --- Estilos de Fundo por Fase --- */

        /* SVG da Nuvem (para Fase 1) */
        .cloud {
            position: absolute;
            width: 150px;
            height: 100px;
            background: #fff;
            border-radius: 50px;
            opacity: 0.8;
            z-index: -1;
            animation: moveClouds 20s linear infinite;
        }
        .cloud::before, .cloud::after {
            content: '';
            position: absolute;
            background: #fff;
            border-radius: 50%;
        }
        .cloud::before {
            width: 80px; height: 80px; top: -30px; left: 30px;
        }
        .cloud::after {
            width: 60px; height: 60px; top: -20px; right: 20px;
        }
        #cloud1 { top: 10%; left: -150px; transform: scale(0.8); animation-duration: 25s; }
        #cloud2 { top: 30%; left: -150px; transform: scale(1.1); animation-duration: 18s; animation-delay: -5s; }
        #cloud3 { top: 60%; left: -150px; transform: scale(0.6); animation-duration: 30s; animation-delay: -10s; }

        @keyframes moveClouds {
            from { transform: translateX(0); }
            to { transform: translateX(800px); } /* Move através do contêiner */
        }

        /* SVG do Sol (para Fase 2) */
        .sun {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 80px;
            height: 80px;
            background: #FFD700;
            border-radius: 50%;
            box-shadow: 0 0 20px #FFD700;
            z-index: -1;
            animation: pulseSun 3s infinite ease-in-out;
            display: none; /* Oculto por padrão */
        }
        @keyframes pulseSun {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        /* Estrelas (para Fase 3) */
        .star {
            position: absolute;
            width: 3px;
            height: 3px;
            background: #fff;
            border-radius: 50%;
            z-index: -1;
            animation: twinkle 1.5s infinite ease-in-out alternate;
            display: none; /* Oculto por padrão */
        }
        @keyframes twinkle {
            from { opacity: 0.3; }
            to { opacity: 1; }
        }

        /* FASE 1: Céu Limpo */
        .fase-1 {
            background-color: var(--cor-fundo-fase1);
        }
        .fase-1 .cloud { display: block; }
        .fase-1 .sun, .fase-1 .star { display: none; }

        /* FASE 2: Estrada e Sol */
        .fase-2 {
            /* Gradiente: céu, estrada, grama */
            background: linear-gradient(
                to bottom,
                var(--cor-fundo-fase2-ceu) 0%,
                var(--cor-fundo-fase2-ceu) 65%,
                var(--cor-fundo-fase2-estrada) 65%,
                var(--cor-fundo-fase2-estrada) 75%,
                var(--cor-fundo-fase2-grama) 75%,
                var(--cor-fundo-fase2-grama) 100%
            );
        }
        .fase-2 .sun { display: block; }
        .fase-2 .cloud, .fase-2 .star { display: none; }

        /* FASE 3: Noite Estrelada */
        .fase-3 {
            background-color: var(--cor-fundo-fase3);
        }
        .fase-3 .star { display: block; }
        .fase-3 .cloud, .fase-3 .sun { display: none; }

        /* Modal de Fim de Jogo / Parabéns */
        #modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: none; /* Oculto por padrão */
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        #modal-content {
            background: #fff;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            animation: popIn 0.3s ease;
        }

        @keyframes popIn {
            from { transform: scale(0.5); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        #modal-content h2 {
            font-size: 2.5em;
            margin-bottom: 20px;
        }

        #modal-content p {
            font-size: 1.2em;
            margin-bottom: 30px;
        }

        #modal-content button {
            font-family: 'Fredoka', sans-serif;
            font-size: 1.2em;
            font-weight: 600;
            padding: 12px 30px;
            border: none;
            border-radius: 10px;
            background-color: #4CAF50;
            color: white;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        #modal-content button:hover {
            background-color: #45a049;
        }

    </style>
</head>
<body>

    <!-- Contêiner Principal do Jogo -->
    <div id="game-container" class="fase-1">
        
        <!-- Elementos de Fundo (são movidos pelo JS/CSS) -->
        <!-- Fase 1: Nuvens -->
        <div class="cloud" id="cloud1"></div>
        <div class="cloud" id="cloud2"></div>
        <div class="cloud" id="cloud3"></div>
        <!-- Fase 2: Sol -->
        <div class="sun"></div>
        <!-- Fase 3: Estrelas (geradas por JS) -->
        <div id="star-container"></div>


        <!-- Canvas do Jogo -->
        <canvas id="tetris-canvas" width="300" height="600"></canvas>

        <!-- Painel de Informações -->
        <div id="info-panel">
            <div class="info-box">
                <h3>Pontos</h3>
                <p id="score">0</p>
            </div>
            <div class="info-box">
                <h3>Linhas</h3>
                <p id="lines">0</p>
            </div>
            <div class="info-box">
                <h3>Fase</h3>
                <p id="fase">1</p>
            </div>
            <!-- Novo Painel de Poder -->
            <div class="info-box power-box">
                <h3>Poder</h3>
                <p id="power-status">---</p>
            </div>
        </div>
    </div>

    <!-- Modal de Fim de Jogo / Parabéns -->
    <div id="modal">
        <div id="modal-content">
            <h2 id="modal-title">Fim de Jogo!</h2>
            <p id="modal-message">Tente novamente!</p>
            <button id="restart-button">Jogar de Novo</button>
        </div>
    </div>


    <script>
        // --- Configuração Inicial ---

        const canvas = document.getElementById('tetris-canvas');
        const ctx = canvas.getContext('2d');
        const COLS = 10;
        const ROWS = 20;
        const BLOCK_SIZE = 30;

        // Elementos da UI
        const scoreEl = document.getElementById('score');
        const linesEl = document.getElementById('lines');
        const faseEl = document.getElementById('fase');
        const powerStatusEl = document.getElementById('power-status'); // Novo
        const gameContainer = document.getElementById('game-container');
        const starContainer = document.getElementById('star-container');
        const modal = document.getElementById('modal');
        const modalTitle = document.getElementById('modal-title');
        const modalMessage = document.getElementById('modal-message');
        const restartButton = document.getElementById('restart-button');

        // Cores das Peças (infantis e claras)
        const COLORS = [
            '#FFFFFF', // Cor 0 (vazio)
            '#FF69B4', // 1: Rosa (I)
            '#00BFFF', // 2: Azul (J)
            '#FFD700', // 3: Amarelo (L)
            '#ADFF2F', // 4: Verde (O)
            '#FF6347', // 5: Vermelho/Tomate (S)
            '#BA55D3', // 6: Roxo (T)
            '#FFA500',  // 7: Laranja (Z)
            // --- Cores Especiais ---
            '#333333', // 8: Bomba (será animada)
            '#FFFFFF'  // 9: Laser (será animada)
        ];

        // Formas das Peças (Tetrominoes)
        const SHAPES = [
            [], // Vazio
            [[1, 1, 1, 1]], // 1: I
            [[2, 0, 0], [2, 2, 2]], // 2: J
            [[0, 0, 3], [3, 3, 3]], // 3: L
            [[4, 4], [4, 4]], // 4: O
            [[0, 5, 5], [5, 5, 0]], // 5: S
            [[6, 6, 6], [0, 6, 0]], // 6: T
            [[7, 7, 0], [0, 7, 7]], // 7: Z
            // --- Peças Especiais ---
            [[8]] // 8: Bomba (1x1)
            // O Laser é a peça 'I' (1) com uma flag
        ];

        // Variáveis de Estado do Jogo
        let grid;
        let currentPiece;
        let score;
        let linesCleared;
        let fase;
        let gameOver;
        let dropInterval;       // Velocidade atual (muda com fases e slow-mo)
        let baseDropInterval;   // Velocidade da fase atual
        let dropCounter;
        let lastTime;
        let animationFrameId;
        let congratsShown;

        // Variáveis dos Poderes
        let slowMoActive = false;
        let slowMoTimer = 0;

        // --- Funções Principais do Jogo ---

        /**
         * Inicializa ou reinicia o jogo
         */
        function init() {
            grid = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
            score = 0;
            linesCleared = 0;
            fase = 1;
            gameOver = false;
            congratsShown = false;
            baseDropInterval = 1000; // 1 segundo (Fase 1)
            dropInterval = baseDropInterval;
            dropCounter = 0;
            lastTime = 0;

            // Reseta poderes
            deactivateSlowMo(true); // Reseta forçado
            powerStatusEl.textContent = "---";
            canvas.classList.remove('slow-mo');

            generateStars(50);
            updateUI();
            updateBackground();
            modal.style.display = 'none';

            spawnPiece();

            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            gameLoop();
        }

        /**
         * O loop principal do jogo (baseado em requestAnimationFrame)
         */
        function gameLoop(time = 0) {
            if (gameOver) return;

            const deltaTime = time - lastTime;
            lastTime = time;
            dropCounter += deltaTime;

            // Gerencia o timer da Câmera Lenta
            if (slowMoActive) {
                slowMoTimer -= deltaTime;
                powerStatusEl.textContent = `Lento! ${Math.ceil(slowMoTimer / 1000)}s`;
                if (slowMoTimer <= 0) {
                    deactivateSlowMo();
                }
            }

            // Acelera a queda se a seta para baixo estiver pressionada
            if (isDownPressed) {
                dropCounter += dropInterval; // Força uma queda
                isDownPressed = false; 
            }

            if (dropCounter > dropInterval) {
                pieceDrop();
                dropCounter = 0;
            }

            draw();
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        /**
         * Gera uma nova peça aleatória no topo
         */
        function spawnPiece() {
            let shapeIndex;
            let isLaser = false;

            // Chance de 7% de ser uma Bomba
            if (Math.random() < 0.07) {
                shapeIndex = 8; // Bomba
            } else {
                shapeIndex = Math.floor(Math.random() * 7) + 1; // Peças normais (1-7)
            }
            
            const shape = SHAPES[shapeIndex];
            
            // Se for uma peça 'I' (índice 1), 15% de chance de ser Laser
            if (shapeIndex === 1 && Math.random() < 0.15) {
                isLaser = true;
            }

            currentPiece = {
                x: Math.floor((COLS - shape[0].length) / 2),
                y: 0,
                shape: shape,
                colorIndex: isLaser ? 9 : shapeIndex, // Cor 9 para Laser
                isLaser: isLaser
            };

            // Verifica se o jogo acabou (colisão no spawn)
            if (checkCollision(currentPiece.shape, currentPiece.x, currentPiece.y)) {
                gameOver = true;
                showModal("Fim de Jogo!", `Pontuação final: ${score}`);
            }
        }

        // --- Funções de Movimentação e Colisão ---

        /**
         * Move a peça automaticamente para baixo (gravidade)
         */
        function pieceDrop() {
            if (!checkCollision(currentPiece.shape, currentPiece.x, currentPiece.y + 1)) {
                currentPiece.y++;
            } else {
                // A peça colidiu. Verifica se é um poder antes de solidificar
                if (currentPiece.colorIndex === 8) { // É Bomba!
                    activateBomb(currentPiece.x, currentPiece.y);
                } else if (currentPiece.isLaser) { // É Laser!
                    activateLaser();
                } else {
                    // Peça normal, solidifica
                    solidifyPiece();
                }
                
                // Verifica se linhas foram completadas (mesmo após poderes)
                clearLines();
                // Gera a próxima peça
                spawnPiece();
            }
        }

        function move(dir) {
            // ... (código original sem mudanças) ...
            if (!checkCollision(currentPiece.shape, currentPiece.x + dir, currentPiece.y)) {
                currentPiece.x += dir;
            }
        }

        function rotate() {
            // ... (código original sem mudanças) ...
            const originalShape = currentPiece.shape;
            // Não deixa rotacionar Bomba ou peça 'O'
            if (currentPiece.colorIndex === 8 || currentPiece.colorIndex === 4) return;
            
            const N = originalShape.length;
            const M = originalShape[0].length;
            
            const newShape = Array.from({ length: M }, () => Array(N).fill(0));
            for (let r = 0; r < N; r++) {
                for (let c = 0; c < M; c++) {
                    newShape[c][N - 1 - r] = originalShape[r][c];
                }
            }

            let newX = currentPiece.x;
            if (checkCollision(newShape, newX, currentPiece.y)) {
                if (!checkCollision(newShape, newX + 1, currentPiece.y)) {
                    newX++;
                } 
                else if (!checkCollision(newShape, newX - 1, currentPiece.y)) {
                    newX--;
                } 
                else if (!checkCollision(newShape, newX + 2, currentPiece.y)) {
                    newX += 2;
                }
                else if (!checkCollision(newShape, newX - 2, currentPiece.y)) {
                    newX -= 2;
                }
                else {
                    return; 
                }
            }
            
            currentPiece.shape = newShape;
            currentPiece.x = newX;
        }

        function checkCollision(shape, newX, newY) {
            // ... (código original sem mudanças) ...
            for (let y = 0; y < shape.length; y++) {
                for (let x = 0; x < shape[y].length; x++) {
                    if (shape[y][x] !== 0) {
                        const realX = newX + x;
                        const realY = newY + y;

                        if (realX < 0 || realX >= COLS || realY >= ROWS) {
                            return true;
                        }
                        if (realY >= 0 && grid[realY][realX] !== 0) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        function solidifyPiece() {
            // ... (código original sem mudanças) ...
            currentPiece.shape.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        grid[currentPiece.y + y][currentPiece.x + x] = value;
                    }
                });
            });
        }

        /**
         * Verifica e limpa linhas completas
         */
        function clearLines() {
            let linesToClear = 0;
            for (let r = ROWS - 1; r >= 0; r--) {
                if (grid[r].every(cell => cell !== 0)) {
                    linesToClear++;
                    grid.splice(r, 1);
                    grid.unshift(Array(COLS).fill(0));
                    r++;
                }
            }

            if (linesToClear > 0) {
                linesCleared += linesToClear;
                score += linesToClear * 100 * linesToClear; 
                
                // ATIVA CÂMERA LENTA (se limpar 2+ linhas)
                if (linesToClear >= 2 && !slowMoActive) {
                    activateSlowMo();
                }
                
                updateFase();
                updateUI();
            }
        }
        
        // --- Funções dos PODERES ---

        /**
         * PODER: Ativa o Bloco-Bomba (limpa 3x3)
         */
        function activateBomb(x, y) {
            score += 50; // Pontos bônus pela bomba
            for (let r = y - 1; r <= y + 1; r++) {
                for (let c = x - 1; c <= x + 1; c++) {
                    // Verifica se está dentro dos limites do grid
                    if (r >= 0 && r < ROWS && c >= 0 && c < COLS) {
                        grid[r][c] = 0; // Limpa o bloco
                    }
                }
            }
        }
        
        /**
         * PODER: Ativa o Laser de Coluna
         */
        function activateLaser() {
            const shape = currentPiece.shape;
            const x = currentPiece.x;
            
            // Descobre quais colunas o laser ocupa
            let colsToClear = new Set();
            shape.forEach((row, y) => {
                row.forEach((value, c) => {
                    if (value !== 0) {
                        colsToClear.add(x + c);
                    }
                });
            });

            // Limpa as colunas
            colsToClear.forEach(col => {
                for (let r = 0; r < ROWS; r++) {
                    if (grid[r][col] !== 0) {
                        grid[r][col] = 0;
                        score += 10; // Pontos por bloco destruído
                    }
                }
            });
        }
        
        /**
         * PODER: Ativa a Câmera Lenta
         */
        function activateSlowMo() {
            slowMoActive = true;
            slowMoTimer = 7000; // 7 segundos
            // Salva a velocidade da fase ATUAL, para não bugar
            baseDropInterval = dropInterval; 
            dropInterval = 1500; // Super lento
            canvas.classList.add('slow-mo');
        }

        /**
         * PODER: Desativa a Câmera Lenta
         */
        function deactivateSlowMo(forceReset = false) {
            if (forceReset || slowMoActive) {
                slowMoActive = false;
                slowMoTimer = 0;
                // Restaura a velocidade da fase (que está em baseDropInterval)
                dropInterval = baseDropInterval;
                powerStatusEl.textContent = "---";
                canvas.classList.remove('slow-mo');
            }
        }


        // --- Funções de UI e Nível ---

        function updateUI() {
            // ... (código original sem mudanças) ...
            scoreEl.textContent = score;
            linesEl.textContent = linesCleared;
            faseEl.textContent = fase;
        }

        /**
         * Verifica e atualiza a fase do jogo
         */
        function updateFase() {
            let newFase = fase;
            let newInterval = baseDropInterval; // Começa com o intervalo atual

            if (linesCleared >= 13) {
                newFase = 3;
                newInterval = 400; // Fase 3: Rápido
            } else if (linesCleared >= 6) {
                newFase = 2;
                newInterval = 700; // Fase 2: Médio
            } else {
                newFase = 1;
                newInterval = 1000; // Fase 1: Normal
            }

            // Verifica se a fase mudou
            if (newFase !== fase) {
                fase = newFase;
                updateBackground();
                // Efeito de piscar
                gameContainer.classList.add('fase-change-flash');
                setTimeout(() => {
                    gameContainer.classList.remove('fase-change-flash');
                }, 500);
            }
            
            // Atualiza a velocidade base
            baseDropInterval = newInterval;
            // Se a câmera lenta NÃO estiver ativa, aplica a nova velocidade
            if (!slowMoActive) {
                dropInterval = baseDropInterval;
            }
            
            // Condição de "Parabéns" (ex: ao atingir 20 linhas)
            if (linesCleared >= 20 && !congratsShown) {
                // ... (código original sem mudanças) ...
                congratsShown = true;
                gameOver = true;
                showModal("Parabéns!", "Você zerou todas as fases!");
            }
        }

        function updateBackground() {
            // ... (código original sem mudanças) ...
            gameContainer.classList.remove('fase-1', 'fase-2', 'fase-3');
            gameContainer.classList.add('fase-' + fase);
        }

        function generateStars(count) {
            // ... (código original sem mudanças) ...
            starContainer.innerHTML = ''; 
            const containerWidth = gameContainer.offsetWidth;
            const containerHeight = gameContainer.offsetHeight;

            // Evita erro se o container não tiver tamanho na primeira execução
            if (containerWidth === 0 || containerHeight === 0) return;

            for (let i = 0; i < count; i++) {
                const star = document.createElement('div');
                star.className = 'star';
                star.style.top = `${Math.random() * containerHeight}px`;
                star.style.left = `${Math.random() * containerWidth}px`;
                star.style.animationDelay = `${Math.random() * 1.5}s`;
                star.style.transform = `scale(${Math.random() * 1.5 + 0.5})`;
                starContainer.appendChild(star);
            }
        }

        function showModal(title, message) {
            // ... (código original sem mudanças) ...
            modalTitle.textContent = title;
            modalMessage.textContent = message;
            modal.style.display = 'flex';
        }

        // --- Funções de Desenho ---

        /**
         * Limpa e desenha o estado atual do jogo no canvas
         */
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // Desenha o grid (peças solidificadas)
            drawGrid();
            // Desenha a peça atual
            drawPiece(currentPiece);
        }

        /**
         * Desenha o grid (peças que já caíram)
         */
        function drawGrid() {
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (grid[r][c] !== 0) {
                        drawBlock(c, r, grid[r][c]); // Passa o índice da cor
                    }
                }
            }
        }

        /**
         * Desenha a peça que está caindo
         */
        function drawPiece(piece) {
            piece.shape.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        // 'value' aqui é o índice da cor (1-9)
                        drawBlock(piece.x + x, piece.y + y, value);
                    }
                });
            });
        }

        /**
         * Função auxiliar para desenhar um único bloco (COM EFEITOS)
         */
        function drawBlock(x, y, colorIndex) {
            let color = COLORS[colorIndex];

            // Efeito da Bomba (pisca entre preto e vermelho)
            if (colorIndex === 8) {
                color = (Math.floor(lastTime / 200) % 2 === 0) ? '#333' : '#FF0000';
            } 
            // Efeito do Laser (pulsa entre branco e azul)
            else if (colorIndex === 9) {
                color = (Math.floor(lastTime / 150) % 2 === 0) ? '#FFFFFF' : '#00BFFF';
            }

            ctx.fillStyle = color;
            ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.lineWidth = 2;
            ctx.strokeRect(x * BLOCK_SIZE + 1, y * BLOCK_SIZE + 1, BLOCK_SIZE - 2, BLOCK_SIZE - 2);
        }

        // --- Controles de Teclado ---

        let isDownPressed = false; 

        document.addEventListener('keydown', (e) => {
            if (gameOver) return;

            if (e.key === 'ArrowLeft') {
                move(-1);
            } else if (e.key === 'ArrowRight') {
                move(1);
            } else if (e.key === 'ArrowDown') {
                isDownPressed = true;
            } else if (e.key === 'ArrowUp') {
                rotate();
            }
        });

        // Event listener para o botão de reiniciar
        restartButton.addEventListener('click', init);

        // --- Iniciar o Jogo ---
        init();

    </script>
</body>
</html>
